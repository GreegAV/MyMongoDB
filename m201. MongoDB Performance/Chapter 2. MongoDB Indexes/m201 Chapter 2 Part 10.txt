In this lesson, we're going to talk about text indexes.

And specifically, we're to discuss how we can create inquiry with text indexes.

What kind of implications text indexes have on the number index keys that are generated.

And finally, we're going to discuss some of the costs that are associated with text searches and text indexes.

Oftentimes, we store text in our documents.

And for certain use cases, it can be useful to search for documents based on the words that are a part of those text fields.

For example, here I have a document with English words describing this product as a long sleeved t-shirt.

Now using MongoDB's default query engine, I can specify a string that exactly matches the string specified in this document if I wanted to find this document.

Now there are obvious limitations to querying in this way.

Users of our application are unlikely to know the exact string to input to return this document.

One possible solution to this problem would be to take advantage of MongoDB's built-in regular expression support.

While this would work, there are performance disadvantages.

As you'll learn in another lesson, regular expressions don't have the best performance.

And this is even true when they use indexes.

And this is where text indexes come into play.

Rather than specifying that we want our indexes to be ascending or descending, rather, we pass a special text keyword to createIndex.

This allows us to create a special text index.

By doing this, were able to leverage MongoDB's full text search capabilities, while avoiding collection scans.

Under the hood, this works very similarly to multi-key indexes.

The server is going to process this text field and create an index key for every unique word in the string.

So in this case, MongoDB would create five index keys for this document.

This is because Unicode considers both spaces and hyphens as text delimiters.

The five index keys would be mongodb, long, sleeve, t, and shirt.

You'll notice that each of these tokens are also lowercase.

That's because, by default, text indexes are case insensitive.

With regards to performance, like multi-key indexes, we want to be aware that the bigger our text fields are, the more index keys per document we'll be producing.

This will affect the number of index keys that the query engine needs to examine as well as the overall size of our index.

You'll want to watch very closely how big our index is getting to make sure that it fits entirely in RAM.

You'll also want to be aware that this means that it's going to take longer than normal to build this kind of index, than a traditional index.

And of course, since we're generating more index keys, we'll also see a more significant decrease in write performance, than with a typical index.

One strategy for reducing the number of index keys that need to be examined, would be to create a compound text index.

Here I'm creating a compound index on category and product name.

And this allows us to limit the number of text keys that need to be inspected by limiting on the clothing category.

We'll only need to examine index keys that fit the clothing category, rather than looking at all index keys.

Let's go ahead and try out some of the other features of text indexes from the shell.

First, let's connect to the m201 database.

From here, we can go ahead and insert some example documents.

Here, I have inserted two documents.

One that says that "MongoDB is the best," another that says that "MongoDB is the worst." More on this in a second.

And of course, I can go ahead and now create a text index on the statement field.

And now when I search for the special $text and $search operators for the phrase "MongoDB best," you'll see that the first document returned says, "MongoDB is the worst." And the second document it returns says, "MongoDB is the best." So what exactly happened here?

Why was worst before best.

And why did worst even appear at all?

Well, first of all, it's important to understand that text queries logically "or" each delimited word.

So in this case, when we say that we're searching for "MongoDB best," we're searching for any documents that include MongoDB or any documents that include the word best.

To address this issue, we can project the special textScore value to our returned results.

The $text operator assigns a score to each document, based on the relevance of that document for a given search query.

And now that we've projected this field, we can go ahead and sort by the same projected field.

Now the documents that best match our search query are at the top of our results.

Let's go ahead and recap what we've learned.

We discussed how to create inquiry with text indexes.

We also discussed some of the implications of having so many text keys being generated by text indexes.

And finally, we talked about some of the associated costs with tech searches in general.